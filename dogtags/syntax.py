#!/usr/bin/python3
import re
import os
from glob import iglob

class KeywordHighlight():
    def __init__(self, name, highlight_group):
        self.global_tags = set()
        self.local_tags = dict()

        self.name = name
        self.highlight_group = highlight_group

    def add_tag(self, tag, scope=None):
        if scope != None:
            if scope not in self.local_tags:
                self.local_tags[scope] = set()

            dest = self.local_tags[scope]
        else:
            dest = self.global_tags

        dest.add(tag.tag_name)

    def generate_script(self, out):
        if len(self.global_tags) != 0:
            out.write("syn keyword %s %s\n" % (self.name, " ".join(keywords)))

        first_conditional_printed = False
        for scope in self.local_tags.keys():
            if first_conditional_printed:
                out.write("else")
            else:
                first_conditional_printed = True

            # Compare against the full path if the tag paths are absolute
            if scope.startswith("/"):
                out.write("if expand('%%:p') == '%s'\n" % scope)
            else:
                out.write("if @%% == '%s'\n" % scope)

            out.write("\tsyn keyword %s %s\n" % (self.name, " ".join(keywords)))

            if len(self.global_tags) == 0:
                out.write("\thi def link %s %s\n" % (self.name,
                                                     self.highlight_group))

        if first_conditional_printed:
            out.write("endif\n")

        if len(self.global_tags) != 0:
            out.write("hi def link %s %s\n" % (self.name, self.highlight_group))

# Extracts information from an already existing keyword file. Right now we just
# support extracting keywords for generating a list of reserved keywords.
class SyntaxFile():
    keyword_rule_matcher = re.compile(r"^\s*syn(t(a(x)?)?)?\s+keyword\s+(?P<rule_name>\w+)\b(?P<rule_def>.*)")
    keyword_matcher = re.compile(r"\w+")
    keyword_arguments = set(["conceal", "cchar", "contained", "containedin",
                             "nextgroup", "transparent", "skipwhite",
                             "skipnl", "skipempty", "conceallevel",
                             "concealcursor"])
    SEARCH_DIRS = [
            "/usr/share/vim/vim*/syntax/",
    ]

    def _find_syntax_file(name):
        found = None

        for search_dir in SyntaxFile.SEARCH_DIRS:
            for path in iglob(search_dir):
                if name in os.listdir(path):
                    found = path + name
                    break

        if found == None:
            raise Exception("Syntax file %s not found in standard vim directories" % name)

        return found

    def is_keyword(word):
        if SyntaxFile.keyword_matcher.match(word) != None and \
           word not in SyntaxFile.keyword_arguments:
            return True
        else:
            return False

    def __init__(self, name):
        self.keywords = dict()

        for line in open(SyntaxFile._find_syntax_file(name)).readlines():
            rule = self.keyword_rule_matcher.match(line)

            if rule == None:
                continue

            rule_name = rule.group("rule_name")
            keywords = rule.group("rule_def").strip().split(" ")

            new_keywords = set([k for k in keywords if SyntaxFile.is_keyword(k)])
            if rule_name not in self.keywords:
                self.keywords[rule_name] = new_keywords
            else:
                self.keywords[rule_name] |= new_keywords

"""
Creates highlighting rules to ensure that a set of keywords are highlighted,
but does so using 'syn match' instead of 'syn keyword'. This is has much more
overhead then plain keyword matching.

In order to reduce the overhead introduced by regular expressions to a bare
minimum; the regular expressions are generated by walking a radix trie of all
of the keywords that would be highlighted in each file scope.
"""
class MatchHighlight():
    class RadixTrie():
        def __init__(self, key=None, endpoint=False):
            self.is_endpoint = endpoint
            self.key = key
            self.edges = dict()

        def __iter__(self):
            return iter(self.edges.values())

        def __len__(self):
            return len(self.edges)

        def add(self, key):
            assert len(key) > 0

            if key[0] in self.edges:
                key_len = len(key)
                existing_branch = self.edges[key[0]]
                existing_key_len = len(existing_branch.key)

                match_count = 0
                while key[match_count] == existing_branch.key[match_count]:
                    match_count += 1
                    if match_count == key_len:
                        existing_branch.is_endpoint = True
                        return
                    elif match_count == existing_key_len:
                        # If we've matched the whole existing key, travel down
                        # the branch normally
                        self.edges[key[0]].add(key[existing_key_len:])
                        return

                # We only matched part of the key, split the branch where we
                # stopped matching
                new = MatchHighlight.RadixTrie(existing_branch.key[:match_count])
                self.edges[key[0]] = new

                key = key[match_count:]
                existing_branch.key = existing_branch.key[match_count:]

                new.edges[existing_branch.key[0]] = existing_branch
                new.edges[key[0]] = MatchHighlight.RadixTrie(key, True)
            else:
                self.edges[key[0]] = MatchHighlight.RadixTrie(key, True)

    def __init__(self, name, highlight_group, *items,
                 begin_expr=None, end_expr=None):
        self.name = name
        self.highlight_group = highlight_group
        self.begin_expr = begin_expr
        self.end_expr = end_expr
        self._trie = MatchHighlight.RadixTrie()
        self._local_tags = dict()

        for item in items:
            if iter(item):
                for i in item:
                    self.add(i)
            else:
                self.add(item)

    def add_tag(self, tag, scope=None):
        if scope != None:
            if scope not in self._local_tags:
                self._local_tags[scope] = list()
            self._local_tags[scope] = tag.tag_name

        self._trie.add(key)

    def print_trie(self):
        def print_branch(branch, indent_level=0):
            if branch.key != None:
                print("%s%s%s%s" % ("  " * indent_level, branch.key,
                                    ":" if len(branch) > 0 else "",
                                    " <end>" if branch.is_endpoint else ""))
                indent_level += 1

            for sub_branch in branch:
                print_branch(sub_branch, indent_level)

        print_branch(self._trie)

    def generate_script(self, out=open('/dev/stdout', 'w')):
        def gen(branch):
            if branch.key != None:
                ret = branch.key
            else:
                ret = ""

            if len(branch):
                # Paranthesis can be excluded for the top level
                if branch.key != None:
                    ret += '\('

                ret += '\|'.join([gen(sub_branch) for sub_branch in branch])

                if branch.key != None:
                    ret += '\)'
                    if branch.is_endpoint:
                        ret += '\?'

            return ret

        out.write("syn match %s " % self.name)
        if self.begin_expr != None or self.end_expr != None:
            if self.begin_expr != None:
                out.write(self.begin_expr)

            out.write('\(')

        out.write(gen(self._trie))

        if self.begin_expr != None or self.end_expr != None:
            out.write('\)')

            if self.end_expr != None:
                out.write(self.end_expr)

        out.write('\n')
        out.write('hi def link %s %s\n' % (self.name, self.highlight_group))
